{
	// Place your C++ workspace snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and 
	// description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope 
	// is left empty or omitted, the snippet gets applied to all languages. The prefix is what is 
	// used to trigger the snippet and the body will be expanded and inserted. Possible variables are: 
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. 
	// Placeholders with the same ids are connected.
	// Example:
	// "Print to console": {
	// 	"scope": "javascript,typescript",
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"LCS": {
		"prefix": "LCS",
		"body": [
		  "int lcs(string s1,string s2,int m,int n){",
		  "    if(m==0||n==0){",
		  "        return 0;",
		  "    }",
		  "    else{",
		  "    if(s1[m-1]==s2[n-1]){",
		  "        return 1+lcs(s1,s2,m-1,n-1);",
		  "    }",
		  "    else{",
		  "        return max(lcs(s1,s2,m,n-1),lcs(s1,s2,m-1,n));",
		  "    }",
		  "    }",
		  "}",
		  "//Using DynamicProgramming(memoisation):",
		  "int lcsdp(string s1,string s2,int m,int n){",
		  "    vector<vector<int>> memo(m+1,vector<int>(n+1,-1));",
		  "    if(memo[m][n]==-1){",
		  "        if(m==0||n==0){",
		  "            memo[m][n]=0;",
		  "        }",
		  "        else{",
		  "            if(s1[m-1]==s2[n-1]){",
		  "                memo[m][n]=1+lcs(s1,s2,m-1,n-1);",
		  "        }",
		  "        else{",
		  "            memo[m][n]=max(lcs(s1,s2,m,n-1),lcs(s1,s2,m-1,n));",
		  "        }",
		  "        }",
		  "        return memo[m][n];",
		  "    }",
		  "    return memo[m][n];",
		  "}"
		],
		"description": "THIS IS USED TO FIND LCS OF STRING"
	  },
	  "LinkedList": {
		"prefix": "LinkedList",
		"body": [
		  "struct Node",
		  "{",
		  "    int data;",
		  "    Node *next;",
		  "    Node (int x)",
		  "    {",
		  "        data=x;",
		  "        next=NULL;",
		  "    }",
		  "};",
		  "//TRAVERSAL IN LINKED LIST//",
		  "//Iterative code::",
		  "void printlist(Node *head){",
		  "    while (head!=NULL)",
		  "    {",
		  "        cout<<(head->data)<<\" \";",
		  "        head=head->next;",
		  "    }",
		  "    ",
		  "}",
		  "//Recursive Code::",
		  "void rprint(Node *head){",
		  "    if(head==NULL){",
		  "        return;",
		  "    }",
		  "     cout<<(head->data)<<\" \";",
		  "     rprint(head->next);",
		  "     ",
		  "}",
		  "",
		  "//INSERTION IN LL:",
		  "//Insertbegin function::",
		  "Node *insertbegin(Node *head,int x){",
		  "    Node *temp=new Node(x);",
		  "    temp->next=head;",
		  "    return temp;",
		  "",
		  "}",
		  "//InsertEND function::",
		  "Node *insertend(Node *head,int x){",
		  "    Node *temp=new Node(x);",
		  "    if(head==NULL)",
		  "    return temp;",
		  "    Node *curr=head;",
		  "    while (curr->next!=NULL)",
		  "    {",
		  "        curr=curr->next;",
		  "    }",
		  "    curr->next=temp;",
		  "    return head;",
		  "    ",
		  "}",
		  "//Insert at a position",
		  "Node *insatpos(Node *head,int a,int x){",
		  "    Node *temp=new Node(a);",
		  "    if(x==1){",
		  "        temp->next=head;",
		  "        return temp;",
		  "    }",
		  "    Node *curr=head;",
		  "    while (x-2>0&&curr!=NULL)",
		  "    {",
		  "        curr=curr->next;",
		  "        x--;",
		  "    }",
		  "    if(curr==NULL){",
		  "        return head;",
		  "    }",
		  "    temp->next=curr->next;",
		  "    curr->next=temp;",
		  "    return head;",
		  "}",
		  "//Sorted insert",
		  "Node *sortinsert(Node *head,int x){",
		  "    Node *temp=new Node(x);",
		  "    if(head==NULL){",
		  "        return temp;",
		  "    }",
		  "    if(head->data>temp->data){",
		  "        temp->next=head;",
		  "        return temp;",
		  "    }",
		  "    Node *curr=head;",
		  "    while ((curr->next->data<temp->data) && (curr->next!=NULL)){",
		  "         curr=curr->next;",
		  "    }",
		  "    temp->next=curr->next;",
		  "    curr->next=temp;",
		  "    return head;",
		  "}",
		  "",
		  "//DELETION IN LL:",
		  "//deleting first element",
		  "Node *deltefirst(Node *head){",
		  "    if(head==NULL){",
		  "        return NULL;",
		  "",
		  "    }",
		  "    Node *temp=head->next;",
		  "    delete(head);",
		  "    return temp;",
		  "}",
		  "//deleting last element",
		  "Node *deletelast(Node *head){",
		  "    Node *curr=head;",
		  "    if (head==NULL)",
		  "    {",
		  "        return NULL;",
		  "    }",
		  "    if(head->next==NULL){",
		  "        delete(head);",
		  "        return NULL;",
		  "    }",
		  "    while(curr->next->next!=NULL){",
		  "        curr=curr->next;",
		  "    }",
		  "    delete(curr->next);",
		  "    curr->next=NULL;",
		  "    return head;",
		  "}",
		  " Node* deleteNode(Node *head,int x)",
		  "{",
		  "    //Your code here",
		  "    Node *curr=head;",
		  "    if(head==NULL)",
		  "    return NULL;",
		  "    if(x==1){",
		  "    curr=curr->next;",
		  "    delete(head);",
		  "    return curr;",
		  "    }",
		  "    while(((x-2)>0)&&(curr->next->next!=NULL)){",
		  "        curr=curr->next;",
		  "        x--;",
		  "    }",
		  "    delete(curr->next);",
		  "    curr->next=curr->next->next;",
		  "    return head;",
		  "}",
		  "",
		  "//SEARCHING IN LL:",
		  "int search(Node *head,int x){",
		  "    Node *curr=head;",
		  "    int a=1;",
		  "    while(curr!=NULL){",
		  "        if(curr->data==x){",
		  "            return a;",
		  "        }",
		  "        curr=curr->next;",
		  "        a++;",
		  "        ",
		  "    }",
		  "     ",
		  "    return -1;",
		  "    ",
		  "}",
		  "",
		  "//Middle element",
		  "Node *middle(Node *head){",
		  "    Node *curr=head;",
		  "    int cnt=0;",
		  "    while (curr!=NULL)",
		  "    {",
		  "        curr=curr->next;",
		  "        cnt++;",
		  "    }",
		  "    curr=head;",
		  "    for (int i = 0; i < cnt/2; i++)",
		  "    {",
		  "        curr=curr->next;",
		  "    }",
		  "    cout<<curr->data;",
		  "}",
		  "//Get element from last nth node:",
		  "Node *lastNThnode(Node *head,int x){",
		  "    Node *curr=head;",
		  "    int cnt=0;",
		  "    while (curr!=NULL)",
		  "    {",
		  "        curr=curr->next;",
		  "        cnt++;",
		  "    }",
		  "    curr=head;",
		  "    for(int i=0;i<cnt-x;i++){",
		  "        curr=curr->next;",
		  "    }",
		  "    cout<<curr->data;",
		  "}",
		  "//Reverse a LinkedList:",
		  "Node *reversell(Node *head){",
		  "    vector<int> v;",
		  "    Node *curr=head;",
		  "    while (curr!=NULL)",
		  "    {",
		  "        v.push_back(curr->data);",
		  "        curr=curr->next;",
		  "    }",
		  "    curr=head;",
		  "    while (curr!=NULL)",
		  "    {   ",
		  "        curr->data=v.back();",
		  "        curr=curr->next;",
		  "        v.pop_back();",
		  "    }",
		  "    return head;",
		  "    ",
		  "}"
		],
		"description": "LinkedList function"
	  },
	  "KADANE ALGORITHM": {
		"prefix": "kadane",
		"body": [
		  " //KADANE ALGORITHM",
		  "long long maxSubarraySum(int arr[], int n){",
		  "        ",
		  "        // Your code here",
		  "        int prefix=0;",
		  "        int max=INT_MIN,start=0,s=0,end=0;",
		  "        for(int i=0;i<n;i++){",
		  "            prefix+=arr[i];",
		  "             ",
		  "            if(max<prefix) {",
		  "                max=prefix;",
		  "                start=s;",
		  "                end=i;",
		  "            }  ",
		  "            if(prefix<0){",
		  "                prefix=0;",
		  "                s=i+1;",
		  "            }",
		  "             ",
		  "        }",
		  "        cout<< max<<\" \"<<start<<\" \"<<end<<\" \";",
		  "        ",
		  "    }"
		],
		"description": "used to find subarrayof maxsum"
	  },
	  "prefixsum": {
		"prefix": "prefixsum",
		"body": [
		  "int prefixsum(int arr[],int n){",
		  "    //int n=sizeof(arr)/sizeof(int);",
		  "    int prsum[n];",
		  "    prsum[0]=arr[0];",
		  "    for(int i=1;i<n;i++){",
		  "        prsum[i]=prsum[i-1]+arr[i];",
		  "    }",
		  "    for(int i=0;i<n;i++){",
		  "        cout<<prsum[i]<<\" \";",
		  "    }",
		  "}"
		],
		"description": "prefixsum"
	  }
}